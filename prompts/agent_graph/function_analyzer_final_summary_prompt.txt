Based on {EXAMPLES_COUNT} usage examples, generate a driver specification for `{FUNCTION_SIGNATURE}`.

{ARCHETYPE_KNOWLEDGE}

---

OUTPUT SPECIFICATION

## 1. Archetype & Reference Template

Primary pattern: [Choose ONE: Stateless Parser | Object Lifecycle | State Machine | Stream Processor | Round-trip | File-based]

Reference: See FUZZER_COOKBOOK.md Scenario [X]

Evidence: Pattern observed in {N}/{EXAMPLES_COUNT} examples

## 2. Preconditions (CRITICAL - violations cause crashes)

For each precondition:
```
MUST: {condition_description}
Reason: {why_required}
Evidence: Example #{N}, source code line {file:line}
Violation → {crash_type: segfault/assertion/memory_corruption}
Driver code: if (!{condition}) return 0;
```

## 3. Setup Sequence

**Standard flow** (confidence: {N}/{EXAMPLES_COUNT} examples):
```c
step1: {init_function}();        // Establishes: {state/resource}
step2: {config_function}();      // Configures: {what}
step3: {FUNCTION_SIGNATURE}(...) // Main operation
step4: {cleanup_function}();     // Prevents: {leak/corruption}
```

**Alternative flows**: [{describe_if_multiple_patterns}]

## 4. Parameter Fuzzing Strategy

For each parameter:
```yaml
{param_name}:
  type: {type}
  construction: [{how_real_callers_create_it}]
  strategy: [DIRECT_FUZZ | CONSTRAIN | FIX]
  constraints: [{if_CONSTRAIN}]
  fixed_value: [{if_FIX}]
  driver_code: |
    {actual_C_code}
```

## 5. Postconditions & Error Handling

**Return value semantics** (from examples):
- Success pattern: [{how_indicated}]
- Failure pattern: [{error_values}]
- Evidence: Example #{N} checks `{code_snippet}`

**Status checks required**:
For each API call, identify and enforce its postcondition:

```yaml
{function_name}:
  postcondition: "Returns NULL on allocation failure"
  evidence: "Examples #1, #3 both check if (!ptr)"
  violation_risk: "Segfault in subsequent use"
  driver_code: "if (!ptr) return 0;"
```

**Common error patterns**:
- Pointers: NULL indicates failure
- Integers: Negative values indicate errors
- Booleans: false/0 indicates failure

**Driver template** (adjust based on actual API):
```c
// Step 1: Create object
ptr = api_create();
if (!ptr) return 0;  // Postcondition: NULL on OOM

// Step 2: Process data
ret = api_process(ptr, data, size);
if (ret < 0) goto cleanup;  // Postcondition: negative on error

cleanup:
  api_destroy(ptr);  // Precondition: ptr must be valid
  return 0;
```

**Resource management**:
-  Stack buffer (< {size})
-  Heap allocation (malloc/free or RAII)
-  Temp file (use /tmp/fuzz_{pid})
-  Static buffer (performance optimization)

## 6. Driver Skeleton

```c
#include <stddef.h>
#include <stdint.h>
#include "{header}.h"

int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  // Input validation
  if (size < {min} || size > {max}) return 0;
  
  // Resource allocation
  {resource_declarations}
  
  // Setup sequence
  {init_calls}
  if ({check_failed}) return 0;  // Early exit on setup failure
  
  // Main API call
  {ret} = {FUNCTION_SIGNATURE}({args});
  if ({check_failed}) goto cleanup;  // Check return value
  
  // Cleanup
cleanup:
  {cleanup_calls_in_reverse_order}
  return 0;
}
```

## 7. Common Pitfalls to Avoid

**Initialization Errors**:
-  Missing library init (e.g., `initGEOS()`) → crash from uninitialized state
-  Missing error handler setup → uncaught internal errors

**Data & Argument Errors**:
-  Unchecked NULL pointers → segmentation fault
-  Missing bounds validation → buffer overflow
-  Modifying const input → copy data first

**Call Sequence Errors**:
-  Double-free → object destroyed twice
-  Use-after-free → object used after destroy
-  Wrong cleanup order → dependency violation

**Resource Management**:
-  Memory leak → missing free/destroy
-  Stack overflow → use heap for large buffers
-  Unbounded loop → add `max_iterations` limit

## 8. Confidence Assessment

High confidence (≥70% examples): [{list}]
Medium confidence (30-70%): [{list}]
Needs verification (<30%): [{list}]

---

Format: Provide specification in sections above. Support every claim with evidence. Keep it concise and code-focused.

**Note**: If you identify new API constraints, error patterns, or key decisions during your analysis, mark them using XML tags:
- `<api_constraint>constraint description</api_constraint>` for API usage rules
- `<known_fix error="error pattern">solution</known_fix>` for error fix patterns  
- `<decision reason="rationale">decision content</decision>` for important decisions

These will be extracted and shared with other agents to build consensus knowledge.

