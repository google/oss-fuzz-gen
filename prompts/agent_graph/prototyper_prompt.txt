Translate the following specification into a compilable fuzz target:

**Project**: {PROJECT_NAME}
**Function**: {FUNCTION_NAME}
**Signature**: {FUNCTION_SIGNATURE}

**Specification**:
{FUNCTION_ANALYSIS}

{SKELETON_CODE}

{ADDITIONAL_CONTEXT}

**Task**: Generate the fuzz target by:
1. **CRITICAL**: Use ONLY the "Reference Skeleton" provided below (NOT any skeleton in the specification text)
   - The Reference Skeleton contains the correct, validated header files
   - DO NOT guess or modify header paths - use them exactly as provided in Reference Skeleton
2. Follow the Setup Sequence exactly (call functions in specified order)
3. Add Precondition checks before each call (as specified)
4. Add Postcondition checks after each call (as specified)
5. Construct parameters using the Parameter Strategy (DIRECT_FUZZ/CONSTRAIN/FIX)
6. Study existing fuzz targets in the project for coding style (but NOT for headers - use Reference Skeleton headers)

**Output Format**:

<conclusion>
[One paragraph: Which archetype skeleton you used, what checks you added, any project-specific adaptations]
</conclusion>

<fuzz target>
[Complete C/C++ code, ready to compile]
</fuzz target>

<build script>
[Only if modifications needed]
</build script>

**Rules**:
- Follow the specification exactly
- Do not add checks not specified
- Do not omit checks that are specified
- Use the exact setup sequence from the spec
- **MUST use header files EXACTLY as provided in "Reference Skeleton", unless you find some headers or include paths are incorrect.
- Ensure code compiles without modifications

