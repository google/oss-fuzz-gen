â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         ğŸš¨ CRITICAL CONSTRAINT ğŸš¨                            â•‘
â•‘                                                                               â•‘
â•‘  THE TARGET FUNCTION NAME MUST NEVER BE CHANGED UNDER ANY CIRCUMSTANCES!     â•‘
â•‘                                                                               â•‘
â•‘  Target Function: {FUNCTION_NAME}                                            â•‘
â•‘                                                                               â•‘
â•‘  âŒ ABSOLUTELY FORBIDDEN - Common Mistakes:                                   â•‘
â•‘  â€¢ Replacing with similar-named functions (e.g., ada_parse â†’ ada_can_parse)  â•‘
â•‘  â€¢ Adding/removing prefixes (e.g., parse â†’ my_parse, ada_parse â†’ ada::parse) â•‘
â•‘  â€¢ Using "equivalent" functions from the same library                        â•‘
â•‘  â€¢ Changing return type interpretation (e.g., treating void* as bool)        â•‘
â•‘                                                                               â•‘
â•‘  ğŸ“š EXAMPLE - ada-url library has many similar functions:                    â•‘
â•‘     ada_parse()              â† Target function (returns ada_url/void*)       â•‘
â•‘     ada_can_parse()          â† Different function (returns bool)             â•‘
â•‘     ada_parse_with_base()    â† Different function (takes base URL)           â•‘
â•‘     ada_parse_search_params()â† Different function (parses query params)      â•‘
â•‘                                                                               â•‘
â•‘  âš ï¸  IF YOU SEE LINKER ERROR "undefined reference to {FUNCTION_NAME}":       â•‘
â•‘  â€¢ The function does NOT exist in the compiled library                       â•‘
â•‘  â€¢ You CANNOT fix this by changing to a similar function name                â•‘
â•‘  â€¢ You MUST respond: "UNABLE_TO_FIX: function does not exist in library"     â•‘
â•‘                                                                               â•‘
â•‘  âœ… VALIDATION - Your response will be automatically checked:                 â•‘
â•‘  â€¢ Function name {FUNCTION_NAME} must appear in final code                   â•‘
â•‘  â€¢ Function must be called (not just mentioned in comments)                  â•‘
â•‘  â€¢ Violation = immediate rejection + retry penalty                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Fix the compilation errors in the following fuzz target:

**Language**: {LANGUAGE}

**Current Fuzz Target Code**:
```
{CURRENT_CODE}
```

**Compilation Errors**:
{BUILD_ERRORS}

{ADDITIONAL_CONTEXT}

**Your Task**:
Analyze the build errors and fix them while preserving the fuzzing logic and intent.

**SPECIAL CASE - Validation Errors**:
If the error message states "was not called by the fuzz target" or "YOU MUST CALL FUNCTION":
- This is a VALIDATION ERROR, not a compilation error
- The code compiles, but does NOT call the target function
- **FIX**: Add a direct call to the target function inside LLVMFuzzerTestOneInput
- This is CRITICAL - the entire purpose of the fuzzer is to test THIS specific function
- Do not just call it in a helper function - it must be in LLVMFuzzerTestOneInput itself

**Analysis Steps**:

1. **Understand Each Error**:
   - **FIRST: Check if this is a validation error** (function not called)
     * If error contains "was not called by the fuzz target" â†’ VALIDATION ERROR
     * If error contains "YOU MUST CALL FUNCTION" â†’ VALIDATION ERROR
     * Skip to step 3 with plan: add target function call
   - Read each error message carefully
   - Identify the error type (syntax, type mismatch, linker, validation, etc.)
   - Locate the exact line and context where the error occurs

2. **Identify Root Causes**:
   - **VALIDATION ERROR**: Target function not called? â†’ Add direct call, go to step 3
   - **HEADERS (PRIORITY #1)**: Remove internal/private headers (`internal/`, `*_impl.h`), verify exact capitalization (case-sensitive), use provided paths EXACTLY
   - **OTHER**: Type mismatches, wrong signatures, undefined symbols, API misuse

3. **Plan Your Fixes**:
   - Determine the minimal changes needed to fix each error
   - Ensure fixes don't break the fuzzing logic
   - Consider if fixes might introduce new errors
   - Check if the fixes respect function requirements
   - **CRITICAL**: Verify your plan does NOT change the target function name `{FUNCTION_NAME}`

4. **Verify Your Solution**:
   - Mentally test that the fixes address all errors
   - Ensure the fuzzing logic remains intact
   - Confirm all includes are correct and complete
   - Verify type compatibility throughout
   - **FINAL CHECK**: Confirm the code still calls `{FUNCTION_NAME}` (not a similar function)

**Fix Guidelines**:
- Minimal necessary changes only; preserve fuzzing logic; keep readable
- **Target Function (PRIORITY #0 - MOST CRITICAL)**:
  * NEVER change `{FUNCTION_NAME}` to ANY other function, even if names are similar
  * Libraries often have function families with similar names (e.g., `parse`, `can_parse`, `parse_with_base`)
  * Each function has DIFFERENT signatures and purposes - they are NOT interchangeable
  * If linker cannot find `{FUNCTION_NAME}`, report "UNABLE_TO_FIX" - do NOT substitute
  * Before finalizing: grep for `{FUNCTION_NAME}(` to ensure it's still called
- **Headers (PRIORITY #1)**: Remove internal/private, verify case-sensitive paths, use provided paths exactly, no conditional includes, no guessing
- Verify signatures match declarations
- If error is "undefined reference to {FUNCTION_NAME}" and you cannot find the function definition, this means the function doesn't exist - report UNABLE_TO_FIX

**Output Format**:

Provide your complete solution in the following format:

<conclusion>
[Brief explanation covering:
 - What errors were present
 - Root causes you identified
 - How you fixed each issue
 - Any important considerations]
</conclusion>

<fuzz_target>
[Complete corrected fuzz target code - do NOT omit any existing code]
</fuzz_target>

<build_script>
[Modified build script if needed, otherwise omit this section]
</build_script>

**Critical Requirements**:
- **PRESERVE TARGET FUNCTION CALL**: The target function `{FUNCTION_NAME}` MUST remain called with its exact signature. DO NOT replace it with similar-named functions.
  * âŒ WRONG: Replacing `ada_parse` with `ada_can_parse` (different return types!)
  * âŒ WRONG: Replacing `parse_url` with `can_parse_url` (different purposes!)
  * âŒ WRONG: Using wrapper functions or "equivalent" alternatives
  * âœ… CORRECT: Keep calling `{FUNCTION_NAME}` exactly as specified
- **VALIDATE TARGET CALL**: Before submitting, verify `{FUNCTION_NAME}` IS called in LLVMFuzzerTestOneInput
  * Search your final code for the exact string `{FUNCTION_NAME}(`
  * Ensure it's a function call, not just a comment or string
- **HANDLE UNFIXABLE ERRORS**: If `{FUNCTION_NAME}` truly doesn't exist in the library:
  * Add to <conclusion>: "UNABLE_TO_FIX: function {FUNCTION_NAME} does not exist in library"
  * Do NOT attempt to substitute with similar functions
- Provide the FULL corrected code (not just the changed parts)
- Do not use triple backticks (```) inside the XML tags
- Ensure all resources are properly managed
- Maintain the original fuzzing intent
- Keep changes minimal and focused

