<steps>
Follow these steps to write a fuzz target:

Step 1. Determine the information you need to write an effective fuzz target.
This includes:
    * **Source code** of the function under test.
    * **Custom Types and Dependencies** definitions and implementations.
    * **Initialization and setup** requirements and steps.
    * **Build details** and integration steps.
    * Valid and edge-case input values.
    * Environmental and runtime dependencies.

Step 2. Collect information using the Bash tool.
Use the bash tool (see <tool> section) and follow its rules to gather the necessary information. You can collect information from:
    * The existing human written fuzz target at `{FUZZ_TARGET_PATH}`.
    * The existing human written build script `/src/build.sh`.
    * The project source code (in `.`, or `/src/<project-under-test>/`) clone from the project repository.
    * Documentation about the project, the function, and the variables/constants involved.
    * Environment variables.
    * Knowledge about OSS-Fuzz's build infrastructure: It will compile your fuzz target in the same way as the exiting human written fuzz target with the build script.

Step 3. Analyze the function and its parameters.
Understand the function under test by analyzing its source code and documentation:
    * **Purpose and functionality** of the function.
    * **Input processing** and internal logic.
    * **Dependencies** on other functions or global variables.
    * **Error handling** and edge cases.

Step 4. Understand initialization requirements.
Identify what is needed to properly initialize the function:
    * **Header files** and their relative paths used by include statements in the fuzz target.
    * **Complex input parameters or objects** initialization.
    * **Constructor functions** or initialization routines.
    * **Global state** or configuration needs to be set up.
    * **Mocking** external dependencies if necessary.

Step 5. Understand Constraints and edge cases.
For each input parameter, understand:
    * Valid ranges and data types.
    * Invalid or edge-case values (e.g., zero, NULL, predefined constants, maximum values).
    * Special values that trigger different code paths.

Step 6: Plan Fuzz Target Implementation.
Decide how to implement the fuzz target:
    * **Extract parameters** from the `data` and `size` variable of `LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)`.
    * Handle fixed-size versus variable-size data.
    * **Initialize function's parameters** by appropriately mapping the raw input bytes.
    * Ensure that the fuzz target remains deterministic and avoids side effects.
    * Avoid `goto` statements.

Step 7: **Write** the fuzz target code.
Implement the `LLVMFuzzerTestOneInput` function:
    * Header files:
        * Investigate how existing fuzz targets include headers.
        * Investigate where they are located in the project
        * Collect all headers required by your fuzz target and their locations.
        * Include their relative path in the same way as the existing fuzz targets.
    * Macros or Constants:
        * Include or define necessary macros or constants.
    * Input Handling:
        * Use `FuzzedDataProvider` if and only if the fuzz target at `{FUZZ_TARGET_PATH}` is a C++ file.
        * Use `extern "C"` if and only if the fuzz target at `{FUZZ_TARGET_PATH}` is a C++ file.
        * Check that the input size is sufficient.
        * Extract parameters from the input data.
        * Handle any necessary conversions or validations.
    * Function Invocation:
        * Initialize required objects or state.
        * Modify the existing fuzz target at `{FUZZ_TARGET_PATH}` to fuzz the function under test with the fuzzed parameters.
        * Ensure proper error handling.
    *
    * Cleanup:
        * Free any allocated resources.
        * Reset any global state if necessary.

Step 8 (Optional): **Modify** the Build Script.
Write a new build script only if the existing one (`/src/build.sh`) is insufficient:
    * Decide if you need to modify the build script at `/src/build.sh` to successfully build the new fuzz target.
    * Include compilation steps for the project under test.
    * Include compilation steps for the new fuzz target.
    * Specify necessary compiler and linker flags.
    * Ensure all dependencies are correctly linked.

Step 9: Providing Your Conclusion:
    * Provide your conclusion on the FULL new fuzz target and build script **ONLY AFTER** you have gathered all necessary information.
    * Follow the conclusion response protocol (see section <conclusion protocol>).
</steps>

{TYPE_SPECIFIC_PRIMING}
