Generate fuzz target for {FUNCTION_NAME} ({PROJECT_NAME})

SIGNATURE: {FUNCTION_SIGNATURE}

SRS SPECIFICATION:
{SRS_SPECIFICATION}

REFERENCE SKELETON (use these headers):
{SKELETON_CODE}

REQUIREMENTS:
1. MUST call {FUNCTION_NAME} (exact name)
2. Use skeleton headers only (filtered, safe)
3. Implement [MANDATORY] items from SRS
4. Follow API dependencies (init → use → cleanup)

{ADDITIONAL_CONTEXT}

PARAMETER STRATEGY (from SRS):

DEFAULT: FuzzedDataProvider for 2+ parameters

```cpp
#include <fuzzer/FuzzedDataProvider.h>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  FuzzedDataProvider fdp(data, size);
  
  // Split input into varied parameters
  std::string p1 = fdp.ConsumeRandomLengthString(256);
  int p2 = fdp.ConsumeIntegral<int>();
  
  {FUNCTION_NAME}(p1.c_str(), p2);
  return 0;
}
```

DIRECT_FUZZ: Single buffer function (pass-through)
```cpp
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  {FUNCTION_NAME}(data, size);
  return 0;
}
```

CONSTRAIN: Bounded values
```cpp
FuzzedDataProvider fdp(data, size);
int port = fdp.ConsumeIntegralInRange<int>(1, 65535);
{FUNCTION_NAME}(port);
```

CONSTRUCT: Struct/object parameters
```cpp
FuzzedDataProvider fdp(data, size);
struct Config cfg = {0};
cfg.field1 = fdp.ConsumeIntegral<int>();
cfg.field2 = fdp.ConsumeRandomLengthString(256).c_str();
{FUNCTION_NAME}(&cfg);
```

FIX: API requires fixed value (document rationale in SRS)

IMPLEMENTATION STEPS:

1. Headers:
   - Use ONLY reference skeleton headers
   - Filter out internal/*, detail/*, private/*

2. Preconditions:
   - Check PRE-* conditions from SRS
   - Return 0 if preconditions cannot be satisfied

3. Parameter construction:
   - Follow SRS strategy per parameter
   - Use FuzzedDataProvider for multi-param (default)
   - For structs: breakdown fields per SRS field_breakdown

4. API lifecycle:
   - Call init/setup functions if required
   - Call {FUNCTION_NAME}
   - Check POST-* conditions if specified
   - Cleanup in reverse order (destroy → close → cleanup)

5. Multi-API fuzzing (if API dependency analysis provided):
   - Call ALL APIs in recommended order
   - Vary parameters for EACH call
   - Test different combinations
   - Cleanup in reverse order

EXCEPTIONS TO FuzzedDataProvider:
- Single buffer functions (DIRECT_FUZZ)
- API constraints requiring fixed values (must be documented in SRS)

OUTPUT FORMAT:

<conclusion>Skeleton used, [MANDATORY] implemented, {FUNCTION_NAME} called</conclusion>
<fuzz_target>[Complete code with LLVMFuzzerTestOneInput]</fuzz_target>
<build_script>[Only if needed, otherwise omit]</build_script>

CRITICAL REQUIREMENTS:
✅ Follow exact XML format above
✅ Keep <conclusion> brief (max 3 sentences)
✅ Include complete, compilable code in <fuzz_target> - NO placeholders
✅ Confirm {FUNCTION_NAME} is called
❌ No extra commentary outside XML tags
❌ No markdown formatting around XML tags
