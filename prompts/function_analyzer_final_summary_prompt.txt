Based on {EXAMPLES_COUNT} usage examples, generate a machine-readable API specification for `{FUNCTION_SIGNATURE}`.

{ARCHETYPE_KNOWLEDGE}

---

# OUTPUT: JSON Specification in `<srs_json>` tags

<srs_json>
{
  "srs_version": "1.0",
  "target_function": "{exact_function_name}",
  "archetype": {
    "primary_pattern": "...",
    "confidence": "HIGH | MEDIUM | LOW",
    "evidence_count": "{N}/{EXAMPLES_COUNT}"
  },
  "functional_requirements": [
    {"id": "FR-1", "priority": "MANDATORY | RECOMMENDED | OPTIONAL", "requirement": "...", "parameter": "...", "rationale": "...", "verification": {"method": "...", "confidence": "...", "evidence": "..."}, "implementation": {"code": "...", "language": "C"}, "failure_mode": "..."}
  ],
  "preconditions": [
    {"id": "PRE-1", "priority": "...", "requirement": "...", "check_method": "...", "rationale": "...", "evidence": "...", "violation_consequence": "segfault | assertion | memory_corruption"}
  ],
  "postconditions": [
    {"id": "POST-1", "priority": "...", "requirement": "...", "check_method": "...", "rationale": "...", "evidence": "..."}
  ],
  "constraints": [
    {"id": "CON-1", "type": "execution_order | parameter_range | resource_limit", "requirement": "...", "parameter": "...", "valid_range_or_sequence": "...", "rationale": "...", "evidence": "...", "implementation": {"sequence": [{"step": 1, "description": "...", "code": "..."}]}}
  ],
  "parameter_strategies": [
    {
      "parameter": "...", 
      "type": "...", 
      "strategy": "DIRECT_FUZZ | CONSTRAIN | FIX | CONSTRUCT", 
      "construction_method": "...", 
      "constraints": "...", 
      "fixed_value": "...", 
      "driver_code": "...",
      "field_breakdown": {
        "is_complex_type": false,
        "primitive_fields": [
          {"field_path": "...", "field_type": "...", "strategy": "...", "construction": "...", "rationale": "..."}
        ]
      }
    }
  ],
  "quality_attributes": {
    "high_confidence_items": [...],
    "medium_confidence_items": [...],
    "low_confidence_items": [...],
    "evidence_quality": "Complete | Partial | Limited",
    "gaps_and_uncertainties": [...]
  },
  "metadata": {
    "must_call_target": "yes",
    "category": "format_parser | state_machine | stateless_function | object_lifecycle | validator | transformer",
    "complexity": "trivial | simple | moderate | complex",
    "state_model": "stateless | global_state_dependent | object_state_dependent",
    "recommended_approach": "direct_call | via_entry_point",
    "purpose": "...",
    "recommended_test_vectors": [{"name": "...", "description": "..."}]
  }
}
</srs_json>

---

## Field Guidelines:
- **functional_requirements**: Use RFC 2119 keywords (SHALL=mandatory, SHOULD=recommended, MAY=optional)
- **preconditions**: Conditions BEFORE calling target (with violation consequences)
- **postconditions**: Checks AFTER calling target (e.g., return value validation)
- **constraints**: execution_order (call sequence), parameter_range (valid values), resource_limit
- **parameter_strategies**: 
  * **DEFAULT STRATEGY**: For multi-parameter functions, use **FuzzedDataProvider** to split fuzzer input
  * DIRECT_FUZZ: Simple functions with 1-2 parameters that accept raw buffers
  * CONSTRAIN: Parameters need validation/transformation (with FuzzedDataProvider)
  * FIX: **ONLY if absolutely required** (e.g., API precondition violation, documented requirement)
  * CONSTRUCT: For complex struct/class parameters - breakdown to primitive fields
  * **CRITICAL**: Avoid premature use of FIX strategy - it severely limits coverage
  * **field_breakdown**: 
    - Set `is_complex_type: true` for struct/class/union parameters
    - Use FuzzIntrospector API to extract struct field definitions
    - For each primitive field, specify individual fuzzing strategy
    - This enables fine-grained coverage of struct member combinations
- **metadata.must_call_target**: MUST be "yes"
- **metadata.recommended_test_vectors**: At least 3 test scenarios

## Parameter Strategy Decision Guide:

**When to use FuzzedDataProvider (PREFERRED for multi-parameter functions):**
```c
// Example: Function with 3+ parameters
int target_func(const char* input, size_t len, const char* base, int flags);

// GOOD: Split fuzzer input using FuzzedDataProvider
FuzzedDataProvider fdp(data, size);
std::string input_str = fdp.ConsumeRandomLengthString(1024);
std::string base_str = fdp.ConsumeRandomLengthString(256);
int flags = fdp.ConsumeIntegral<int>();
target_func(input_str.c_str(), input_str.length(), base_str.c_str(), flags);
```

**When FIX strategy is acceptable:**
1. API absolutely requires specific values (e.g., magic numbers, version fields)
2. Parameter must be from a small enum set (use ConsumeEnum instead!)
3. Documented constraint that cannot be violated
4. **Document the reason in the rationale field**

**Common ANTI-PATTERNS to avoid:**
❌ BAD: Fixing parameters "for simplicity" → limits coverage
❌ BAD: Fixing because "most examples use constant X" → copy pattern, not value
❌ BAD: Fixing "to avoid errors" → test error paths too!

✅ GOOD: Use FuzzedDataProvider to vary all parameters
✅ GOOD: Test edge cases (empty strings, NULL, max values)
✅ GOOD: Explore multiple code paths through parameter variation

**CONSTRUCT strategy (struct parameters):**
- Breakdown struct to primitive fields with individual strategies
- Query FuzzIntrospector for type definition if available
- Schema: Add `field_breakdown` with `primitive_fields` array
- Each field: `field_path`, `field_type`, `strategy`, `construction`, `rationale`

## Knowledge Sharing Tags (optional):
`<api_constraint>...</api_constraint>` | `<known_fix error="...">...</known_fix>` | `<decision reason="...">...</decision>`
