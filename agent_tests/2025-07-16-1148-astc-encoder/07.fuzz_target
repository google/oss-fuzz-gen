// SPDX-License-Identifier: Apache-2.0
// ----------------------------------------------------------------------------
//  Copyright 2021 Arm Limited.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// ----------------------------------------------------------------------------

#include "astcenc_internal.h"

#include <array>
#include <fuzzer/FuzzedDataProvider.h>
#include <vector>

struct BlockSizes {
  int x;
  int y;
  int z;
};

std::array<BlockSizes, 3> testSz{{
    {4, 4, 1},   // Highest bitrate
    {12, 12, 1}, // Largest 2D block
    {6, 6, 6}    // Largest 3D block
}};

std::array<block_size_descriptor, 3> testBSD;

/**
 * @brief Utility function to create all of the block size descriptors needed.
 */
bool bsd_initializer() {
  for (size_t i = 0; i < testSz.size(); i++) {
    init_block_size_descriptor(testSz[i].x, testSz[i].y, testSz[i].z, false, 4, 1.0f, testBSD[i]);
  }
  return true;
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  // Preinitialize the block size descriptors we need
  static bool init = bsd_initializer();

  // Must have at least 16 bytes for the physical block
  if (size < 16) {
    return 0;
  }

  FuzzedDataProvider stream(data, size);

  // Select a block size to test
  int i = stream.ConsumeIntegralInRange<int>(0, (int)testSz.size() - 1);
  const block_size_descriptor &bsd = testBSD[i];

  // Populate the physical block from fuzzed data
  uint8_t pcb_in[16];
  std::vector<uint8_t> buffer = stream.ConsumeBytes<uint8_t>(16);
  // The buffer may be smaller than 16 if the stream is exhausted
  if (buffer.size() != 16) {
    return 0;
  }
  std::memcpy(pcb_in, buffer.data(), 16);

  // Decompress the physical fuzzed data to a symbolic representation
  symbolic_compressed_block scb;
  physical_to_symbolic(bsd, pcb_in, scb);

  // If the symbolic block is valid, call the function under test
  if (scb.block_type != SYM_BTYPE_ERROR) {
    uint8_t pcb_out[16];
    symbolic_to_physical(bsd, scb, pcb_out);
  }

  return 0;
}